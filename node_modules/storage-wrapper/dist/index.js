"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageWrapper = void 0;
class StorageWrapper {
    constructor(storageType, namespace = '') {
        this.storage = storageType === 'local' ? localStorage : sessionStorage;
        this.namespace = namespace;
        this.callbacks = { set: {}, remove: {}, clear: {}, expired: {} };
    }
    executeCallbacks(action, key, value) {
        const events = this.callbacks[action];
        if (events) {
            Object.keys(events).forEach((event) => {
                events[event](key, value);
            });
        }
    }
    getFullKey(key) {
        return this.namespace ? `${this.namespace}:${key}` : key;
    }
    set(key, value, expirationInMinutes = null) {
        const fullKey = this.getFullKey(key);
        const item = {
            value,
            expiration: expirationInMinutes ? new Date().getTime() + expirationInMinutes * 60000 : null,
        };
        this.storage.setItem(fullKey, JSON.stringify(item));
        this.executeCallbacks('set', key, value);
    }
    get(key) {
        const fullKey = this.getFullKey(key);
        const itemStr = this.storage.getItem(fullKey);
        if (!itemStr)
            return null;
        const item = JSON.parse(itemStr);
        if (item.expiration && new Date().getTime() > item.expiration) {
            this.storage.removeItem(fullKey);
            this.executeCallbacks('expired', key);
            return null;
        }
        return item.value;
    }
    remove(key) {
        const fullKey = this.getFullKey(key);
        this.storage.removeItem(fullKey);
        this.executeCallbacks('remove', key);
    }
    clear() {
        if (this.namespace) {
            Object.keys(this.storage).forEach(key => {
                if (key.startsWith(`${this.namespace}:`)) {
                    this.storage.removeItem(key);
                }
            });
            this.executeCallbacks('clear', '');
        }
        else {
            this.storage.clear();
        }
    }
    on(action, event, callback) {
        if (!this.callbacks[action]) {
            this.callbacks[action] = {};
        }
        const func = new Function('return ' + callback);
        this.callbacks[action] = {
            [event]: func()
        };
    }
    off(action, event) {
        var _a;
        if (this.callbacks[action]) {
            (_a = this.callbacks[action]) === null || _a === void 0 ? true : delete _a[event];
        }
    }
}
exports.StorageWrapper = StorageWrapper;
//# sourceMappingURL=index.js.map